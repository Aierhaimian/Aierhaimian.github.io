---
layout:     post
title:      Android Zygote
subtitle:   安卓zygote守护进程分析！
date:       2019-01-23
author:     Earl
header-img: img/post-bg-new-1.jpg
catalog: true
tags:
    - Android
---

> Android zygote 守护进程分析。

# Zygote: 道生一，一生二，二生三，三生万物

##　前言

老子曰：“道生一，一生二，二生三，三生万物”，zygote是app_process在程序执行期间将其名字修改为zygote的。zygote即受精卵，主要作用就是进行细胞分裂，是Android系统执行APK程序的核心服务。zygote进程首先加载启动ART虚拟机，然后在加载一些系统核心类和资源，这些都是其他APK程序都可能要用到的资源。最后zygote进程进入监听状态。一旦Android上层有创建新APK进程的需求，zygote进程便会为其分裂出新的进程。这个APK新进程，一开始便拥有了ART虚拟机和zygote预先加载的各种系统类和资源，能大大加速apk应用的启动，同时也能节省很大的内存开支。

那么，为什么zygote进程要预先加载系统资源？zygote进程实际上是利用fork分裂出新的进程的，linux内核采用了**写时复制技术**：内核只为新生成的子进程创建虚拟空间结构，它们来自于父进程的虚拟地址结构，但是不为子进程的虚拟地址分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。

通常来说，在利用fork创建出的子进程中会调用exec系统调用，去执行新的其他程序。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。

因为Android上层APK程序不会去修改zygote进程预先加载的系统类和系统资源，所以就不需要为每个APK进程重新分配这些资源，所有APK程序都共用在zygote预先加载的这些资源，所以性能自然也就提高了。

##　启动Zygote

在系统启动脚本文件system/core/rootdir/init.rc中import了init.zygote.rc文件，其中可以看到启动zygote进程的脚本命令：

	service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
	    class main
	    socket zygote stream 660 root system
	    onrestart write /sys/android_power/request_state wake
	    onrestart write /sys/power/state on
	    onrestart restart media
	    onrestart restart netd

service：用于通知init进程创建一个名为"zygote"的进程，这个zygote进程要执行的程序是/system/bin/app_process，后面是要传给app_process的参数。
socket：表示这个zygote进程需要一个名为“zygote”的socket资源，这样启动系统后，就可以在/dev/socket目录下看到有一个名为zygote的文件。这里定义的socket的类型为unix　domain socket，它是用来做本地进程间通信的。

##　启动Service

首先看在system/core/init/builtins.c中的函数do_class_start，此函数启动Service：

	int do_class_start(int nargs, char **args)
	{
		/* Starting a class does not start services
		 * which are explicitly disabled.  They must
		 * be started individually.
		 */
	    service_for_each_class(args[1], service_start_if_not_disabled);
	    return 0;
	}
	
	void service_for_each_class(const char *classname,
		                    void (*func)(struct service *svc))
	{
	    struct listnode *node;
	    struct service *svc;
	    list_for_each(node, &service_list) {
		svc = node_to_item(node, struct service, slist);
		if (!strcmp(svc->classname, classname)) {
		    func(svc);
		}
	    }
	}
	
	static void service_start_if_not_disabled(struct service *svc)
	{   
	    if (!(svc->flags & SVC_DISABLED)) {
		service_start(svc, NULL);
	    } else {
		svc->flags |= SVC_DISABLED_START;
	    }
	}

service_start函数在system/core/init.c中：

	void service_start(struct service *svc, const char *dynamic_args)
	{
	    struct stat s;
	    pid_t pid;
	    int needs_console;
	    int n;
	    char *scon = NULL;
	    int rc;

		/* starting a service removes it from the disabled or reset
		 * state and immediately takes it out of the restarting
		 * state if it was in there
		 */
	    svc->flags &= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));
	    svc->time_started = 0;

		/* running processes require no additional work -- if
		 * they're in the process of exiting, we've ensured
		 * that they will immediately restart on exit, unless
		 * they are ONESHOT
		 */
	    if (svc->flags & SVC_RUNNING) {
		return;
	    }

	    needs_console = (svc->flags & SVC_CONSOLE) ? 1 : 0;
	    if (needs_console && (!have_console)) {
		ERROR("service '%s' requires console\n", svc->name);
		svc->flags |= SVC_DISABLED;
		return;
	    }

	    if (stat(svc->args[0], &s) != 0) {
		ERROR("cannot find '%s', disabling '%s'\n", svc->args[0], svc->name);
		svc->flags |= SVC_DISABLED;
		return;
	    }

	    if ((!(svc->flags & SVC_ONESHOT)) && dynamic_args) {
		ERROR("service '%s' must be one-shot to use dynamic args, disabling\n",
		       svc->args[0]);
		svc->flags |= SVC_DISABLED;
		return;
	    }

	    if (is_selinux_enabled() > 0) {
		if (svc->seclabel) {
		    scon = strdup(svc->seclabel);
		    if (!scon) {
		        ERROR("Out of memory while starting '%s'\n", svc->name);
		        return;
		    }
		} else {
		    char *mycon = NULL, *fcon = NULL;

		    INFO("computing context for service '%s'\n", svc->args[0]);
		    rc = getcon(&mycon);
		    if (rc < 0) {
		        ERROR("could not get context while starting '%s'\n", svc->name);
		        return;
		    }

		    rc = getfilecon(svc->args[0], &fcon);
		    if (rc < 0) {
		        ERROR("could not get context while starting '%s'\n", svc->name);
		        freecon(mycon);
		        return;
		    }

		    rc = security_compute_create(mycon, fcon, string_to_security_class("process"), &scon);
		    if (rc == 0 && !strcmp(scon, mycon)) {
		        ERROR("Warning!  Service %s needs a SELinux domain defined; please fix!\n", svc->name);
		    }
		    freecon(mycon);
		    freecon(fcon);
		    if (rc < 0) {
		        ERROR("could not get context while starting '%s'\n", svc->name);
		        return;
		    }
		}
	    }

	    NOTICE("starting '%s'\n", svc->name);

	    pid = fork();

	    if (pid == 0) {
		struct socketinfo *si;
		struct svcenvinfo *ei;
		char tmp[32];
		int fd, sz;

		umask(077);
		if (properties_inited()) {
		    get_property_workspace(&fd, &sz);
		    sprintf(tmp, "%d,%d", dup(fd), sz);
		    add_environment("ANDROID_PROPERTY_WORKSPACE", tmp);
		}

		for (ei = svc->envvars; ei; ei = ei->next)
		    add_environment(ei->name, ei->value);

		for (si = svc->sockets; si; si = si->next) {
		    int socket_type = (
		            !strcmp(si->type, "stream") ? SOCK_STREAM :
		                (!strcmp(si->type, "dgram") ? SOCK_DGRAM : SOCK_SEQPACKET));
		    int s = create_socket(si->name, socket_type,
		                          si->perm, si->uid, si->gid, si->socketcon ?: scon);
		    if (s >= 0) {
		        publish_socket(si->name, s);
		    }
		}

		freecon(scon);
		scon = NULL;

		if (svc->ioprio_class != IoSchedClass_NONE) {
		    if (android_set_ioprio(getpid(), svc->ioprio_class, svc->ioprio_pri)) {
		        ERROR("Failed to set pid %d ioprio = %d,%d: %s\n",
		              getpid(), svc->ioprio_class, svc->ioprio_pri, strerror(errno));
		    }
		}

		if (needs_console) {
		    setsid();
		    open_console();
		} else {
		    zap_stdio();
		}

	#if 0
		for (n = 0; svc->args[n]; n++) {
		    INFO("args[%d] = '%s'\n", n, svc->args[n]);
		}
		for (n = 0; ENV[n]; n++) {
		    INFO("env[%d] = '%s'\n", n, ENV[n]);
		}
	#endif

		setpgid(0, getpid());

	    /* as requested, set our gid, supplemental gids, and uid */
		if (svc->gid) {
		    if (setgid(svc->gid) != 0) {
		        ERROR("setgid failed: %s\n", strerror(errno));
		        _exit(127);
		    }
		}
		if (svc->nr_supp_gids) {
		    if (setgroups(svc->nr_supp_gids, svc->supp_gids) != 0) {
		        ERROR("setgroups failed: %s\n", strerror(errno));
		        _exit(127);
		    }
		}
		if (svc->uid) {
		    if (setuid(svc->uid) != 0) {
		        ERROR("setuid failed: %s\n", strerror(errno));
		        _exit(127);
		    }
		}
		if (svc->seclabel) {
		    if (is_selinux_enabled() > 0 && setexeccon(svc->seclabel) < 0) {
		        ERROR("cannot setexeccon('%s'): %s\n", svc->seclabel, strerror(errno));
		        _exit(127);
		    }
		}

		if (!dynamic_args) {
		    if (execve(svc->args[0], (char**) svc->args, (char**) ENV) < 0) {
		        ERROR("cannot execve('%s'): %s\n", svc->args[0], strerror(errno));
		    }
		} else {
		    char *arg_ptrs[INIT_PARSER_MAXARGS+1];
		    int arg_idx = svc->nargs;
		    char *tmp = strdup(dynamic_args);
		    char *next = tmp;
		    char *bword;

		    /* Copy the static arguments */
		    memcpy(arg_ptrs, svc->args, (svc->nargs * sizeof(char *)));

		    while((bword = strsep(&next, " "))) {
		        arg_ptrs[arg_idx++] = bword;
		        if (arg_idx == INIT_PARSER_MAXARGS)
		            break;
		    }
		    arg_ptrs[arg_idx] = '\0';
		    execve(svc->args[0], (char**) arg_ptrs, (char**) ENV);
		}
		_exit(127);
	    }

	    freecon(scon);

	    if (pid < 0) {
		ERROR("failed to start '%s'\n", svc->name);
		svc->pid = 0;
		return;
	    }

	    svc->time_started = gettime();
	    svc->pid = pid;
	    svc->flags |= SVC_RUNNING;

	    if (properties_inited())
		notify_service_state(svc->name, "running");
	}
	
##　分析Zygote进程

在Android5.0系统中，进程system_server的父进程是Zygote。其实Zygote服务实际上是一种Select服务模型，是为启动Java代码而生，完成了一次androidRuntime的打开和关闭操作。


在service_start()函数中，每一个Service命令都会促使init进程调用fork()函数来创建一个新的进程，在新的进程中会分析里面的socket选项。对于每一个socket选项来说，都会通过函数create_socket来在/dev/socket目录下创建一个文件。由此可见，函数service_start起了一个解释文件init.rc文件中Service命令的作用。

再看函数create_socket()函数，功能是调用函数socket创建一个Socket，使用文件描述符fd来描述此Socket。

	/*
	 * create_socket - creates a Unix domain socket in ANDROID_SOCKET_DIR
	 * ("/dev/socket") as dictated in init.rc. This socket is inherited by the
	 * daemon. We communicate the file descriptor's value via the environment
	 * variable ANDROID_SOCKET_ENV_PREFIX<name> ("ANDROID_SOCKET_foo").
	 */

	int create_socket(const char *name, int type, mode_t perm, uid_t uid,
		          gid_t gid, const char *socketcon)
	{
	    struct sockaddr_un addr;
	    int fd, ret;
	    char *filecon;

	    if (socketcon)
		setsockcreatecon(socketcon);
	
	    //调用函数socket创建一个Socket，使用文件描述符fd来描述此Socket
	    fd = socket(PF_UNIX, type, 0); 
	    if (fd < 0) {
		ERROR("Failed to open socket '%s': %s\n", name, strerror(errno));
		return -1;
	    }

	    if (socketcon)
		setsockcreatecon(NULL);

	   //为Socket创建一个类型为AF_UNIX的socket地址addr
	    memset(&addr, 0 , sizeof(addr));
	    addr.sun_family = AF_UNIX;
	    snprintf(addr.sun_path, sizeof(addr.sun_path), ANDROID_SOCKET_DIR"/%s",
		     name);

	    ret = unlink(addr.sun_path);
	    if (ret != 0 && errno != ENOENT) {
		ERROR("Failed to unlink old socket '%s': %s\n", name, strerror(errno));
		goto out_close;
	    }

	    filecon = NULL;
	    if (sehandle) {
		ret = selabel_lookup(sehandle, &filecon, addr.sun_path, S_IFSOCK);
		if (ret == 0)
		    setfscreatecon(filecon);
	    }

	    ret = bind(fd, (struct sockaddr *) &addr, sizeof (addr));
	    if (ret) {
		ERROR("Failed to bind socket '%s': %s\n", name, strerror(errno));
		goto out_unlink;
	    }

	    setfscreatecon(NULL);
	    freecon(filecon);

	    chown(addr.sun_path, uid, gid);
	    chmod(addr.sun_path, perm);

	    INFO("Created socket '%s' with mode '%o', user '%d', group '%d'\n",
		 addr.sun_path, perm, uid, gid);

	    return fd;

	out_unlink:
	    unlink(addr.sun_path);
	out_close:
	    close(fd);
	    return -1;
	}
	
再看publish_socket()：

	static void publish_socket(const char *name, int fd)
	{ 
	    char key[64] = ANDROID_SOCKET_ENV_PREFIX;
	    char val[64];

	    strlcpy(key + sizeof(ANDROID_SOCKET_ENV_PREFIX) - 1,
		    name,
		    sizeof(key) - sizeof(ANDROID_SOCKET_ENV_PREFIX));
	    snprintf(val, sizeof(val), "%d", fd);
	    add_environment(key, val);

	    /* make sure we don't close-on-exec */
	    fcntl(fd, F_SETFD, 0);
	}

Zygote函数的入口函数是main，功能是创建AppRuntime变量，然后调用成员函数start启动进程。函数在framework/base/cmds/app_process/app_main.cpp中：

	int main(int argc, char* const argv[])
	{
		    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {
				// Older kernels don't understand PR_SET_NO_NEW_PRIVS and return
				// EINVAL. Don't die on such kernels.
				if (errno != EINVAL) {
				    LOG_ALWAYS_FATAL("PR_SET_NO_NEW_PRIVS failed: %s", strerror(errno));
				    return 12;
				}
		    }

		    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); //AppRuntime继承自AndroidRuntime类
		    // Process command line arguments
		    // ignore argv[0]
		    argc--;
		    argv++;

		    // Everything up to '--' or first non '-' arg goes to the vm.
		    //
		    // The first argument after the VM args is the "parent dir", which
		    // is currently unused.
		    //
		    // After the parent dir, we expect one or more the following internal
		    // arguments :
		    //
		    // --zygote : Start in zygote mode
		    // --start-system-server : Start the system server.
		    // --application : Start in application (stand alone, non zygote) mode.
		    // --nice-name : The nice name for this process.
		    //
		    // For non zygote starts, these arguments will be followed by
		    // the main class name. All remaining arguments are passed to
		    // the main method of this class.
		    //
		    // For zygote starts, all remaining arguments are passed to the zygote.
		    // main function.
		    //
		    // Note that we must copy argument string values since we will rewrite the
		    // entire argument block when we apply the nice name to argv0.

		    int i;
		    for (i = 0; i < argc; i++) {
				if (argv[i][0] != '-') {
				    break;
				}
				if (argv[i][1] == '-' && argv[i][2] == 0) {
				    ++i; // Skip --.
				    break;
				}
				runtime.addOption(strdup(argv[i])); //-------传递的参数是 -Xzygote，结束后i=1
		    }

		    // Parse runtime arguments.  Stop at first unrecognized option.
		    bool zygote = false;
		    bool startSystemServer = false;
		    bool application = false;
		    String8 niceName;
		    String8 className;

		    ++i;  // Skip unused "parent dir" argument. --------------------i=2
		    while (i < argc) {
				const char* arg = argv[i++];
				if (strcmp(arg, "--zygote") == 0) {
					    zygote = true;
					    niceName = ZYGOTE_NICE_NAME;
				} else if (strcmp(arg, "--start-system-server") == 0) {
					    startSystemServer = true;
				} else if (strcmp(arg, "--application") == 0) {
					    application = true;
				} else if (strncmp(arg, "--nice-name=", 12) == 0) {
					    niceName.setTo(arg + 12);
				} else if (strncmp(arg, "--", 2) != 0) {
					    className.setTo(arg);
					    break;
				} else {
					    --i;
					    break;
				}
		    }

		    Vector<String8> args;
		    if (!className.isEmpty()) {
				// We're not in zygote mode, the only argument we need to pass
				// to RuntimeInit is the application argument.
				//
				// The Remainder of args get passed to startup class main(). Make
				// copies of them before we overwrite them with the process name.
				args.add(application ? String8("application") : String8("tool"));
				runtime.setClassNameAndArgs(className, argc - i, argv + i);
		    } else {
				// We're in zygote mode.
				maybeCreateDalvikCache();

				if (startSystemServer) {
				    args.add(String8("start-system-server"));
				}

				char prop[PROP_VALUE_MAX];
				if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) {
				    LOG_ALWAYS_FATAL("app_process: Unable to determine ABI list from property %s.",
					ABI_LIST_PROPERTY);
				    return 11;
				}

				String8 abiFlag("--abi-list=");
				abiFlag.append(prop);
				args.add(abiFlag);

				// In zygote mode, pass all remaining arguments to the zygote
				// main() method.
				for (; i < argc; ++i) {
				    args.add(String8(argv[i]));
				}
		    }

		    if (!niceName.isEmpty()) {
				runtime.setArgv0(niceName.string());
				set_process_name(niceName.string());
		    }

		    if (zygote) {
				runtime.start("com.android.internal.os.ZygoteInit", args);
		    } else if (className) {
				runtime.start("com.android.internal.os.RuntimeInit", args);
		    } else {
				fprintf(stderr, "Error: no class name or --zygote supplied.\n");
				app_usage();
				LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
				return 10;
		    }
	}
	
Zygote的启动函数就是start()，功能是调用startVM在Zygote中创建一个虚拟机实例。函数是start在文件framework/base/core/jni/AndroidRuntime.cpp中：

	/*
	 * Start the Android runtime.  This involves starting the virtual machine
	 * and calling the "static void main(String[] args)" method in the class
	 * named by "className".
	 *
	 * Passes the main function two arguments, the class name and the specified
	 * options string.
	 */
	void AndroidRuntime::start(const char* className, const Vector<String8>& options)
	{
	    ALOGD(">>>>>> START %s uid %d <<<<<<\n",
		    className != NULL ? className : "(unknown)", getuid());

	    static const String8 startSystemServer("start-system-server");

	    /*
	     * 'startSystemServer == true' means runtime is obsolete and not run from
	     * init.rc anymore, so we print out the boot start event here.
	     */
	    for (size_t i = 0; i < options.size(); ++i) {
		if (options[i] == startSystemServer) {
		   /* track our progress through the boot sequence */
		   const int LOG_BOOT_PROGRESS_START = 3000;
		   LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));
		}
	    }

	    const char* rootDir = getenv("ANDROID_ROOT"); //-------------如果没有设置ANDROID_ROOT环境变量，就将其设置为/system
	    if (rootDir == NULL) {
		rootDir = "/system";
		if (!hasDir("/system")) {
		    LOG_FATAL("No root directory specified, and /android does not exist.");
		    return;
		}
		setenv("ANDROID_ROOT", rootDir, 1);
	    }

	    //const char* kernelHack = getenv("LD_ASSUME_KERNEL");
	    //ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);

	    /* start the virtual machine */
	    JniInvocation jni_invocation; //------------------初始化JNI环境，里面做了很重要的工作，加载对应的虚拟机so库
	    jni_invocation.Init(NULL);
	    JNIEnv* env;
	    if (startVm(&mJavaVM, &env) != 0) { //------------------启动虚拟机
		return;
	    }
	    onVmCreated(env); //-----------------该方法是一个虚函数，是由其子类负责实现的

	    /*
	     * Register android functions.
	     */
	    if (startReg(env) < 0) { //----------------------为Android核心类在虚拟机中为其注册所需的的JNI函数
		ALOGE("Unable to register all android natives\n");
		return;
	    }

	    /*
	     * We want to call main() with a String array with arguments in it.
	     * At present we have two arguments, the class name and an option string.
	     * Create an array to hold them.
	     */
	    jclass stringClass;
	    jobjectArray strArray;
	    jstring classNameStr;

	    stringClass = env->FindClass("java/lang/String");
	    assert(stringClass != NULL);
	    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);
	    assert(strArray != NULL);
	    classNameStr = env->NewStringUTF(className);
	    assert(classNameStr != NULL);
	    env->SetObjectArrayElement(strArray, 0, classNameStr);

	    for (size_t i = 0; i < options.size(); ++i) {
		jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());
		assert(optionsStr != NULL);
		env->SetObjectArrayElement(strArray, i + 1, optionsStr);
	    }

	    /*
	     * Start VM.  This thread becomes the main thread of the VM, and will
	     * not return until the VM exits.
	     */
	     // className为传递过来的参数com.android.internal.os.ZygoteInit，该函数作用是将其转换为com/android/internal/os/ZygoteInit
	    char* slashClassName = toSlashClassName(className); 
	    jclass startClass = env->FindClass(slashClassName);
	    if (startClass == NULL) {
		ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
		/* keep going */
	    } else {
		jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
		    "([Ljava/lang/String;)V");
		if (startMeth == NULL) {
		    ALOGE("JavaVM unable to find main() in '%s'\n", className);
		    /* keep going */
		} else {
		    env->CallStaticVoidMethod(startClass, startMeth, strArray);

	#if 0
		    if (env->ExceptionCheck())
		        threadExitUncaughtException(env);
	#endif
		}
	    }
	    free(slashClassName);

	    ALOGD("Shutting down VM\n");
	    if (mJavaVM->DetachCurrentThread() != JNI_OK)
		ALOGW("Warning: unable to detach main thread\n");
	    if (mJavaVM->DestroyJavaVM() != 0)
		ALOGW("Warning: VM did not shut down cleanly\n");
	}
	
AndroidRunTIme.start函数主要完成了三项工作：

1. 启动虚拟机

首先初始化JNI环境：

    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    
   这部分代码实现在Android源码/libnativehelper/JniInvocation.cpp中。这里有一个很重要的步骤，就是加载虚拟机实现so库。Android4.4开始引入了ART虚拟机，但是默认的还是dalvik虚拟机。但是从Andoroid 5.0开始就只有ART虚拟机了。
   
	#ifdef HAVE_ANDROID_OS
	static const char* kLibrarySystemProperty = "persist.sys.dalvik.vm.lib.2";
	static const char* kDebuggableSystemProperty = "ro.debuggable";
	static const char* kDebuggableFallback = "0";  // Not debuggable.
	#endif
	static const char* kLibraryFallback = "libart.so";

我们使用的就是Android系统，所以HAVE_ANDROID_OS必然是设置了，persist.sys.dalvik.vm.lib.2”记录了使用的是哪种虚拟机。在Android 5.0以上版本的设备中，执行如下命令：

	root@loongson2k:/ # getprop persist.sys.dalvik.vm.lib.2
	libart.so
	
可知加载的库就是ART虚拟机的实现库libart.so。

接下来是调用AndroidRuntime的startVm方法启动ART虚拟机:

	/*
	 * Start the Dalvik Virtual Machine.
	 *
	 * Various arguments, most determined by system properties, are passed in.
	 * The "mOptions" vector is updated.
	 *
	 * CAUTION: when adding options in here, be careful not to put the
	 * char buffer inside a nested scope.  Adding the buffer to the
	 * options using mOptions.add() does not copy the buffer, so if the
	 * buffer goes out of scope the option may be overwritten.  It's best
	 * to put the buffer at the top of the function so that it is more
	 * unlikely that someone will surround it in a scope at a later time
	 * and thus introduce a bug.
	 *
	 * Returns 0 on success.
	 */
	int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv)
	{
	    int result = -1;
	    JavaVMInitArgs initArgs;
	    char propBuf[PROPERTY_VALUE_MAX];
	    char stackTraceFileBuf[sizeof("-Xstacktracefile:")-1 + PROPERTY_VALUE_MAX];
	    char dexoptFlagsBuf[PROPERTY_VALUE_MAX];
	    char enableAssertBuf[sizeof("-ea:")-1 + PROPERTY_VALUE_MAX];
	    char jniOptsBuf[sizeof("-Xjniopts:")-1 + PROPERTY_VALUE_MAX];
	    char heapstartsizeOptsBuf[sizeof("-Xms")-1 + PROPERTY_VALUE_MAX];
	    char heapsizeOptsBuf[sizeof("-Xmx")-1 + PROPERTY_VALUE_MAX];
	    char heapgrowthlimitOptsBuf[sizeof("-XX:HeapGrowthLimit=")-1 + PROPERTY_VALUE_MAX];
	    char heapminfreeOptsBuf[sizeof("-XX:HeapMinFree=")-1 + PROPERTY_VALUE_MAX];
	    char heapmaxfreeOptsBuf[sizeof("-XX:HeapMaxFree=")-1 + PROPERTY_VALUE_MAX];
	    char gctypeOptsBuf[sizeof("-Xgc:")-1 + PROPERTY_VALUE_MAX];
	    char backgroundgcOptsBuf[sizeof("-XX:BackgroundGC=")-1 + PROPERTY_VALUE_MAX];
	    char heaptargetutilizationOptsBuf[sizeof("-XX:HeapTargetUtilization=")-1 + PROPERTY_VALUE_MAX];
	    char jitcodecachesizeOptsBuf[sizeof("-Xjitcodecachesize:")-1 + PROPERTY_VALUE_MAX];
	    char dalvikVmLibBuf[PROPERTY_VALUE_MAX];
	    char dex2oatXmsImageFlagsBuf[sizeof("-Xms")-1 + PROPERTY_VALUE_MAX];
	    char dex2oatXmxImageFlagsBuf[sizeof("-Xmx")-1 + PROPERTY_VALUE_MAX];
	    char dex2oatXmsFlagsBuf[sizeof("-Xms")-1 + PROPERTY_VALUE_MAX];
	    char dex2oatXmxFlagsBuf[sizeof("-Xmx")-1 + PROPERTY_VALUE_MAX];
	    char dex2oatCompilerFilterBuf[sizeof("--compiler-filter=")-1 + PROPERTY_VALUE_MAX];
	    char dex2oatImageCompilerFilterBuf[sizeof("--compiler-filter=")-1 + PROPERTY_VALUE_MAX];
	    char dex2oatFlagsBuf[PROPERTY_VALUE_MAX];
	    char dex2oatImageFlagsBuf[PROPERTY_VALUE_MAX];
	    char extraOptsBuf[PROPERTY_VALUE_MAX];
	    char voldDecryptBuf[PROPERTY_VALUE_MAX];
	    enum {
	      kEMDefault,
	      kEMIntPortable,
	      kEMIntFast,
	      kEMJitCompiler,
	    } executionMode = kEMDefault;
	    char profilePeriod[sizeof("-Xprofile-period:")-1 + PROPERTY_VALUE_MAX];
	    char profileDuration[sizeof("-Xprofile-duration:")-1 + PROPERTY_VALUE_MAX];
	    char profileInterval[sizeof("-Xprofile-interval:")-1 + PROPERTY_VALUE_MAX];
	    char profileBackoff[sizeof("-Xprofile-backoff:")-1 + PROPERTY_VALUE_MAX];
	    char profileTopKThreshold[sizeof("-Xprofile-top-k-threshold:")-1 + PROPERTY_VALUE_MAX];
	    char profileTopKChangeThreshold[sizeof("-Xprofile-top-k-change-threshold:")-1 +
		                            PROPERTY_VALUE_MAX];
	    char profileType[sizeof("-Xprofile-type:")-1 + PROPERTY_VALUE_MAX];
	    char profileMaxStackDepth[sizeof("-Xprofile-max-stack-depth:")-1 + PROPERTY_VALUE_MAX];
	    char langOption[sizeof("-Duser.language=") + 3];
	    char regionOption[sizeof("-Duser.region=") + 3];
	    char lockProfThresholdBuf[sizeof("-Xlockprofthreshold:")-1 + PROPERTY_VALUE_MAX];
	    char jitOpBuf[sizeof("-Xjitop:")-1 + PROPERTY_VALUE_MAX];
	    char jitMethodBuf[sizeof("-Xjitmethod:")-1 + PROPERTY_VALUE_MAX];
	    char nativeBridgeLibrary[sizeof("-XX:NativeBridge=") + PROPERTY_VALUE_MAX];

	    bool checkJni = false;
	    property_get("dalvik.vm.checkjni", propBuf, "");
	    if (strcmp(propBuf, "true") == 0) {
		checkJni = true;
	    } else if (strcmp(propBuf, "false") != 0) {
		/* property is neither true nor false; fall back on kernel parameter */
		property_get("ro.kernel.android.checkjni", propBuf, "");
		if (propBuf[0] == '1') {
		    checkJni = true;
		}
	    }
	    ALOGD("CheckJNI is %s\n", checkJni ? "ON" : "OFF");
	    if (checkJni) {
		/* extended JNI checking */
		addOption("-Xcheck:jni");

		/* set a cap on JNI global references */
		addOption("-Xjnigreflimit:2000");

		/* with -Xcheck:jni, this provides a JNI function call trace */
		//addOption("-verbose:jni");
	    }

	    property_get("dalvik.vm.execution-mode", propBuf, "");
	    if (strcmp(propBuf, "int:portable") == 0) {
		executionMode = kEMIntPortable;
	    } else if (strcmp(propBuf, "int:fast") == 0) {
		executionMode = kEMIntFast;
	    } else if (strcmp(propBuf, "int:jit") == 0) {
		executionMode = kEMJitCompiler;
	    }

	    parseRuntimeOption("dalvik.vm.stack-trace-file", stackTraceFileBuf, "-Xstacktracefile:");

	    property_get("dalvik.vm.check-dex-sum", propBuf, "");
	    if (strcmp(propBuf, "true") == 0) {
		/* perform additional DEX checksum tests */
		addOption("-Xcheckdexsum");
	    }

	    property_get("log.redirect-stdio", propBuf, "");
	    if (strcmp(propBuf, "true") == 0) {
		/* convert stdout/stderr to log messages */
		addOption("-Xlog-stdio");
	    }

	    strcpy(enableAssertBuf, "-ea:");
	    property_get("dalvik.vm.enableassertions", enableAssertBuf+sizeof("-ea:")-1, "");
	    if (enableAssertBuf[sizeof("-ea:")-1] != '\0') {
		/* accept "all" to mean "all classes and packages" */
		if (strcmp(enableAssertBuf+sizeof("-ea:")-1, "all") == 0)
		    enableAssertBuf[3] = '\0'; // truncate to "-ea"
		ALOGI("Assertions enabled: '%s'\n", enableAssertBuf);
		addOption(enableAssertBuf);
	    } else {
		ALOGV("Assertions disabled\n");
	    }

	    strcpy(jniOptsBuf, "-Xjniopts:");
	    if (parseRuntimeOption("dalvik.vm.jniopts", jniOptsBuf, "-Xjniopts:")) {
		ALOGI("JNI options: '%s'\n", jniOptsBuf);
	    }

	    /* route exit() to our handler */
	    addOption("exit", (void*) runtime_exit);

	    /* route fprintf() to our handler */
	    addOption("vfprintf", (void*) runtime_vfprintf);

	    /* register the framework-specific "is sensitive thread" hook */
	    addOption("sensitiveThread", (void*) runtime_isSensitiveThread);

	    /* enable verbose; standard options are { jni, gc, class } */
	    //addOption("-verbose:jni");
	    addOption("-verbose:gc");
	    //addOption("-verbose:class");

	    /*
	     * The default starting and maximum size of the heap.  Larger
	     * values should be specified in a product property override.
	     */
	    parseRuntimeOption("dalvik.vm.heapstartsize", heapstartsizeOptsBuf, "-Xms", "4m");
	    parseRuntimeOption("dalvik.vm.heapsize", heapsizeOptsBuf, "-Xmx", "16m");

	    // Increase the main thread's interpreter stack size for bug 6315322.
	    addOption("-XX:mainThreadStackSize=24K");

	    // Set the max jit code cache size.  Note: size of 0 will disable the JIT.
	    parseRuntimeOption("dalvik.vm.jit.codecachesize",
		               jitcodecachesizeOptsBuf,
		               "-Xjitcodecachesize:");

	    parseRuntimeOption("dalvik.vm.heapgrowthlimit", heapgrowthlimitOptsBuf, "-XX:HeapGrowthLimit=");
	    parseRuntimeOption("dalvik.vm.heapminfree", heapminfreeOptsBuf, "-XX:HeapMinFree=");
	    parseRuntimeOption("dalvik.vm.heapmaxfree", heapmaxfreeOptsBuf, "-XX:HeapMaxFree=");
	    parseRuntimeOption("dalvik.vm.heaptargetutilization",
		               heaptargetutilizationOptsBuf,
		               "-XX:HeapTargetUtilization=");

	    property_get("ro.config.low_ram", propBuf, "");
	    if (strcmp(propBuf, "true") == 0) {
	      addOption("-XX:LowMemoryMode");
	    }

	    parseRuntimeOption("dalvik.vm.gctype", gctypeOptsBuf, "-Xgc:");
	    parseRuntimeOption("dalvik.vm.backgroundgctype", backgroundgcOptsBuf, "-XX:BackgroundGC=");

	    /*
	     * Enable or disable dexopt features, such as bytecode verification and
	     * calculation of register maps for precise GC.
	     */
	    property_get("dalvik.vm.dexopt-flags", dexoptFlagsBuf, "");
	    if (dexoptFlagsBuf[0] != '\0') {
		const char* opc;
		const char* val;

		opc = strstr(dexoptFlagsBuf, "v=");     /* verification */
		if (opc != NULL) {
		    switch (*(opc+2)) {
		    case 'n':   val = "-Xverify:none";      break;
		    case 'r':   val = "-Xverify:remote";    break;
		    case 'a':   val = "-Xverify:all";       break;
		    default:    val = NULL;                 break;
		    }

		    if (val != NULL) {
		        addOption(val);
		    }
		}

		opc = strstr(dexoptFlagsBuf, "o=");     /* optimization */
		if (opc != NULL) {
		    switch (*(opc+2)) {
		    case 'n':   val = "-Xdexopt:none";      break;
		    case 'v':   val = "-Xdexopt:verified";  break;
		    case 'a':   val = "-Xdexopt:all";       break;
		    case 'f':   val = "-Xdexopt:full";      break;
		    default:    val = NULL;                 break;
		    }

		    if (val != NULL) {
		        addOption(val);
		    }
		}

		opc = strstr(dexoptFlagsBuf, "m=y");    /* register map */
		if (opc != NULL) {
		    addOption("-Xgenregmap");

		    /* turn on precise GC while we're at it */
		    addOption("-Xgc:precise");
		}
	    }

	    /* enable debugging; set suspend=y to pause during VM init */
	    /* use android ADB transport */
	    addOption("-agentlib:jdwp=transport=dt_android_adb,suspend=n,server=y");

	    parseRuntimeOption("dalvik.vm.lockprof.threshold",
		               lockProfThresholdBuf,
		               "-Xlockprofthreshold:");

	    /* Force interpreter-only mode for selected opcodes. Eg "1-0a,3c,f1-ff" */
	    parseRuntimeOption("dalvik.vm.jit.op", jitOpBuf, "-Xjitop:");

	    /* Force interpreter-only mode for selected methods */
	    parseRuntimeOption("dalvik.vm.jit.method", jitMethodBuf, "-Xjitmethod:");

	    if (executionMode == kEMIntPortable) {
		addOption("-Xint:portable");
	    } else if (executionMode == kEMIntFast) {
		addOption("-Xint:fast");
	    } else if (executionMode == kEMJitCompiler) {
		addOption("-Xint:jit");
	    }

	    // libart tolerates libdvm flags, but not vice versa, so only pass some options if libart.
	    property_get("persist.sys.dalvik.vm.lib.2", dalvikVmLibBuf, "libart.so");
	    bool libart = (strncmp(dalvikVmLibBuf, "libart", 6) == 0);

	    if (libart) {
		// If we booting without the real /data, don't spend time compiling.
		property_get("vold.decrypt", voldDecryptBuf, "");
		bool skip_compilation = ((strcmp(voldDecryptBuf, "trigger_restart_min_framework") == 0) ||
		                         (strcmp(voldDecryptBuf, "1") == 0));

		// Extra options for boot.art/boot.oat image generation.
		parseCompilerRuntimeOption("dalvik.vm.image-dex2oat-Xms", dex2oatXmsImageFlagsBuf,
		                           "-Xms", "-Ximage-compiler-option");
		parseCompilerRuntimeOption("dalvik.vm.image-dex2oat-Xmx", dex2oatXmxImageFlagsBuf,
		                           "-Xmx", "-Ximage-compiler-option");
		if (skip_compilation) {
		    addOption("-Ximage-compiler-option");
		    addOption("--compiler-filter=verify-none");
		} else {
		    parseCompilerOption("dalvik.vm.image-dex2oat-filter", dex2oatImageCompilerFilterBuf,
		                        "--compiler-filter=", "-Ximage-compiler-option");
		}

		// Make sure there is a preloaded-classes file.
		if (!hasFile("/system/etc/preloaded-classes")) {
		    ALOGE("Missing preloaded-classes file, /system/etc/preloaded-classes not found: %s\n",
		          strerror(errno));
		    goto bail;
		}
		addOption("-Ximage-compiler-option");
		addOption("--image-classes=/system/etc/preloaded-classes");

		// If there is a compiled-classes file, push it.
		if (hasFile("/system/etc/compiled-classes")) {
		    addOption("-Ximage-compiler-option");
		    addOption("--compiled-classes=/system/etc/compiled-classes");
		}

		property_get("dalvik.vm.image-dex2oat-flags", dex2oatImageFlagsBuf, "");
		parseExtraOpts(dex2oatImageFlagsBuf, "-Ximage-compiler-option");

		// Extra options for DexClassLoader.
		parseCompilerRuntimeOption("dalvik.vm.dex2oat-Xms", dex2oatXmsFlagsBuf,
		                           "-Xms", "-Xcompiler-option");
		parseCompilerRuntimeOption("dalvik.vm.dex2oat-Xmx", dex2oatXmxFlagsBuf,
		                           "-Xmx", "-Xcompiler-option");
		if (skip_compilation) {
		    addOption("-Xcompiler-option");
		    addOption("--compiler-filter=verify-none");
		} else {
		    parseCompilerOption("dalvik.vm.dex2oat-filter", dex2oatCompilerFilterBuf,
		                        "--compiler-filter=", "-Xcompiler-option");
		}
		property_get("dalvik.vm.dex2oat-flags", dex2oatFlagsBuf, "");
		parseExtraOpts(dex2oatFlagsBuf, "-Xcompiler-option");

	    }

	    /* extra options; parse this late so it overrides others */
	    property_get("dalvik.vm.extra-opts", extraOptsBuf, "");
	    parseExtraOpts(extraOptsBuf, NULL);

	    /* Set the properties for locale */
	    {
		strcpy(langOption, "-Duser.language=");
		strcpy(regionOption, "-Duser.region=");
		readLocale(langOption, regionOption);
		addOption(langOption);
		addOption(regionOption);
	    }

	    /*
	     * Set profiler options
	     */
	    if (libart) {
		// Whether or not the profiler should be enabled.
		property_get("dalvik.vm.profiler", propBuf, "0");
		if (propBuf[0] == '1') {
		    addOption("-Xenable-profiler");
		}

		// Whether the profile should start upon app startup or be delayed by some random offset
		// (in seconds) that is bound between 0 and a fixed value.
		property_get("dalvik.vm.profile.start-immed", propBuf, "0");
		if (propBuf[0] == '1') {
		    addOption("-Xprofile-start-immediately");
		}

		// Number of seconds during profile runs.
		parseRuntimeOption("dalvik.vm.profile.period-secs", profilePeriod, "-Xprofile-period:");

		// Length of each profile run (seconds).
		parseRuntimeOption("dalvik.vm.profile.duration-secs",
		                   profileDuration,
		                   "-Xprofile-duration:");

		// Polling interval during profile run (microseconds).
		parseRuntimeOption("dalvik.vm.profile.interval-us", profileInterval, "-Xprofile-interval:");

		// Coefficient for period backoff.  The the period is multiplied
		// by this value after each profile run.
		parseRuntimeOption("dalvik.vm.profile.backoff-coeff", profileBackoff, "-Xprofile-backoff:");

		// Top K% of samples that are considered relevant when
		// deciding if the app should be recompiled.
		parseRuntimeOption("dalvik.vm.profile.top-k-thr",
		                   profileTopKThreshold,
		                   "-Xprofile-top-k-threshold:");

		// The threshold after which a change in the structure of the
		// top K% profiled samples becomes significant and triggers
		// recompilation. A change in profile is considered
		// significant if X% (top-k-change-threshold) of the top K%
		// (top-k-threshold property) samples has changed.
		parseRuntimeOption("dalvik.vm.profile.top-k-ch-thr",
		                   profileTopKChangeThreshold,
		                   "-Xprofile-top-k-change-threshold:");

		// Type of profile data.
		parseRuntimeOption("dalvik.vm.profiler.type", profileType, "-Xprofile-type:");

		// Depth of bounded stack data
		parseRuntimeOption("dalvik.vm.profile.stack-depth",
		                   profileMaxStackDepth,
		                   "-Xprofile-max-stack-depth:");

		// Native bridge library. "0" means that native bridge is disabled.
		property_get("ro.dalvik.vm.native.bridge", propBuf, "");
		if (propBuf[0] == '\0') {
		    ALOGW("ro.dalvik.vm.native.bridge is not expected to be empty");
		} else if (strcmp(propBuf, "0") != 0) {
		    snprintf(nativeBridgeLibrary, sizeof("-XX:NativeBridge=") + PROPERTY_VALUE_MAX,
		             "-XX:NativeBridge=%s", propBuf);
		    addOption(nativeBridgeLibrary);
		}
	    }

	    initArgs.version = JNI_VERSION_1_4;
	    initArgs.options = mOptions.editArray();
	    initArgs.nOptions = mOptions.size();
	    initArgs.ignoreUnrecognized = JNI_FALSE;

	    /*
	     * Initialize the VM.
	     *
	     * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread.
	     * If this call succeeds, the VM is ready, and we can start issuing
	     * JNI calls.
	     */
	    if (JNI_CreateJavaVM(pJavaVM, pEnv, &initArgs) < 0) {
		ALOGE("JNI_CreateJavaVM failed\n");
		goto bail;
	    }

	    result = 0;

	bail:
	    return result;
	}
	
ii. 向虚拟机注册需要的Native函数

基本Android的每个模块都有一些native实现需要和Java代码关联起来，前面也说过了事先注册能够提高性能。

调用AndroidRuntime类中的startReg注册JNI函数：

	/*
	 * Register android native functions with the VM.
	 */
	/*static*/ int AndroidRuntime::startReg(JNIEnv* env)
	{
		    /*
		     * This hook causes all future threads created in this process to be
		     * attached to the JavaVM.  (This needs to go away in favor of JNI
		     * Attach calls.)
		     */
		    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);

		    ALOGV("--- registering native functions ---\n");

		    /*
		     * Every "register" function calls one or more things that return
		     * a local reference (e.g. FindClass).  Because we haven't really
		     * started the VM yet, they're all getting stored in the base frame
		     * and never released.  Use Push/Pop to manage the storage.
		     */
		    env->PushLocalFrame(200);

		    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {
			env->PopLocalFrame(NULL);
			return -1;
		    }
		    env->PopLocalFrame(NULL);

		    //createJavaThread("fubar", quickTest, (void*) "hello");

		    return 0;
	}

其中gRegJNI是一个数组：

	static const RegJNIRec gRegJNI[] = {
	    REG_JNI(register_com_android_internal_os_RuntimeInit),
	    REG_JNI(register_android_os_SystemClock),
	    REG_JNI(register_android_util_EventLog),
	    REG_JNI(register_android_util_Log),
	    REG_JNI(register_android_util_FloatMath),
	    REG_JNI(register_android_content_AssetManager),
	    REG_JNI(register_android_content_StringBlock),
	    REG_JNI(register_android_content_XmlBlock),
	    REG_JNI(register_android_emoji_EmojiFactory),
	    REG_JNI(register_android_text_AndroidCharacter),
	    REG_JNI(register_android_text_StaticLayout),
	    REG_JNI(register_android_text_AndroidBidi),
	    REG_JNI(register_android_view_InputDevice),
	    REG_JNI(register_android_view_KeyCharacterMap),
	    REG_JNI(register_android_os_Process),
	    REG_JNI(register_android_os_SystemProperties),
	    REG_JNI(register_android_os_Binder),
	    REG_JNI(register_android_os_Parcel),
	    REG_JNI(register_android_nio_utils),
	    REG_JNI(register_android_graphics_Graphics),
	    REG_JNI(register_android_view_DisplayEventReceiver),
	    REG_JNI(register_android_view_RenderNode),
	    REG_JNI(register_android_view_RenderNodeAnimator),
	    REG_JNI(register_android_view_GraphicBuffer),
	    REG_JNI(register_android_view_GLES20Canvas),
	    REG_JNI(register_android_view_HardwareLayer),
	    REG_JNI(register_android_view_ThreadedRenderer),
	    REG_JNI(register_android_view_Surface),
	    REG_JNI(register_android_view_SurfaceControl),
	    REG_JNI(register_android_view_SurfaceSession),
	    REG_JNI(register_android_view_TextureView),
	    REG_JNI(register_com_android_internal_view_animation_NativeInterpolatorFactoryHelper),
	    REG_JNI(register_com_google_android_gles_jni_EGLImpl),
	    REG_JNI(register_com_google_android_gles_jni_GLImpl),
	    REG_JNI(register_android_opengl_jni_EGL14),
	    REG_JNI(register_android_opengl_jni_EGLExt),
	    REG_JNI(register_android_opengl_jni_GLES10),
	    REG_JNI(register_android_opengl_jni_GLES10Ext),
	    REG_JNI(register_android_opengl_jni_GLES11),
	    REG_JNI(register_android_opengl_jni_GLES11Ext),
	    REG_JNI(register_android_opengl_jni_GLES20),
	    REG_JNI(register_android_opengl_jni_GLES30),
	    REG_JNI(register_android_opengl_jni_GLES31),
	    REG_JNI(register_android_opengl_jni_GLES31Ext),

	    REG_JNI(register_android_graphics_Bitmap),
	    REG_JNI(register_android_graphics_BitmapFactory),
	    REG_JNI(register_android_graphics_BitmapRegionDecoder),
	    REG_JNI(register_android_graphics_Camera),
	    REG_JNI(register_android_graphics_CreateJavaOutputStreamAdaptor),
	    REG_JNI(register_android_graphics_Canvas),
	    REG_JNI(register_android_graphics_CanvasProperty),
	    REG_JNI(register_android_graphics_ColorFilter),
	    REG_JNI(register_android_graphics_DrawFilter),
	    REG_JNI(register_android_graphics_FontFamily),
	    REG_JNI(register_android_graphics_Interpolator),
	    REG_JNI(register_android_graphics_LayerRasterizer),
	    REG_JNI(register_android_graphics_MaskFilter),
	    REG_JNI(register_android_graphics_Matrix),
	    REG_JNI(register_android_graphics_Movie),
	    REG_JNI(register_android_graphics_NinePatch),
	    REG_JNI(register_android_graphics_Paint),
	    REG_JNI(register_android_graphics_Path),
	    REG_JNI(register_android_graphics_PathMeasure),
	    REG_JNI(register_android_graphics_PathEffect),
	    REG_JNI(register_android_graphics_Picture),
	    REG_JNI(register_android_graphics_PorterDuff),
	    REG_JNI(register_android_graphics_Rasterizer),
	    REG_JNI(register_android_graphics_Region),
	    REG_JNI(register_android_graphics_Shader),
	    REG_JNI(register_android_graphics_SurfaceTexture),
	    REG_JNI(register_android_graphics_Typeface),
	    REG_JNI(register_android_graphics_Xfermode),
	    REG_JNI(register_android_graphics_YuvImage),
	    REG_JNI(register_android_graphics_pdf_PdfDocument),
	    REG_JNI(register_android_graphics_pdf_PdfEditor),
	    REG_JNI(register_android_graphics_pdf_PdfRenderer),

	    REG_JNI(register_android_database_CursorWindow),
	    REG_JNI(register_android_database_SQLiteConnection),
	    REG_JNI(register_android_database_SQLiteGlobal),
	    REG_JNI(register_android_database_SQLiteDebug),
	    REG_JNI(register_android_os_Debug),
	    REG_JNI(register_android_os_FileObserver),
	    REG_JNI(register_android_os_MessageQueue),
	    REG_JNI(register_android_os_SELinux),
	    REG_JNI(register_android_os_Trace),
	    REG_JNI(register_android_os_UEventObserver),
	    REG_JNI(register_android_net_LocalSocketImpl),
	    REG_JNI(register_android_net_NetworkUtils),
	    REG_JNI(register_android_net_TrafficStats),
	    REG_JNI(register_android_os_MemoryFile),
	    REG_JNI(register_com_android_internal_os_ZygoteInit),
	    REG_JNI(register_com_android_internal_os_Zygote),
	    REG_JNI(register_com_android_internal_util_VirtualRefBasePtr),
	    REG_JNI(register_android_hardware_Camera),
	    REG_JNI(register_android_hardware_camera2_CameraMetadata),
	    REG_JNI(register_android_hardware_camera2_legacy_LegacyCameraDevice),
	    REG_JNI(register_android_hardware_camera2_legacy_PerfMeasurement),
	    REG_JNI(register_android_hardware_camera2_DngCreator),
	    REG_JNI(register_android_hardware_SensorManager),
	    REG_JNI(register_android_hardware_SerialPort),
	    REG_JNI(register_android_hardware_SoundTrigger),
	    REG_JNI(register_android_hardware_UsbDevice),
	    REG_JNI(register_android_hardware_UsbDeviceConnection),
	    REG_JNI(register_android_hardware_UsbRequest),
	    REG_JNI(register_android_hardware_location_ActivityRecognitionHardware),
	    REG_JNI(register_android_media_AudioRecord),
	    REG_JNI(register_android_media_AudioSystem),
	    REG_JNI(register_android_media_AudioTrack),
	    REG_JNI(register_android_media_JetPlayer),
	    REG_JNI(register_android_media_RemoteDisplay),
	    REG_JNI(register_android_media_ToneGenerator),

	    REG_JNI(register_android_opengl_classes),
	    REG_JNI(register_android_server_NetworkManagementSocketTagger),
	    REG_JNI(register_android_ddm_DdmHandleNativeHeap),
	    REG_JNI(register_android_backup_BackupDataInput),
	    REG_JNI(register_android_backup_BackupDataOutput),
	    REG_JNI(register_android_backup_FileBackupHelperBase),
	    REG_JNI(register_android_backup_BackupHelperDispatcher),
	    REG_JNI(register_android_app_backup_FullBackup),
	    REG_JNI(register_android_app_ActivityThread),
	    REG_JNI(register_android_app_NativeActivity),
	    REG_JNI(register_android_view_InputChannel),
	    REG_JNI(register_android_view_InputEventReceiver),
	    REG_JNI(register_android_view_InputEventSender),
	    REG_JNI(register_android_view_InputQueue),
	    REG_JNI(register_android_view_KeyEvent),
	    REG_JNI(register_android_view_MotionEvent),
	    REG_JNI(register_android_view_PointerIcon),
	    REG_JNI(register_android_view_VelocityTracker),

	    REG_JNI(register_android_content_res_ObbScanner),
	    REG_JNI(register_android_content_res_Configuration),

	    REG_JNI(register_android_animation_PropertyValuesHolder),
	    REG_JNI(register_com_android_internal_content_NativeLibraryHelper),
	    REG_JNI(register_com_android_internal_net_NetworkStatsFactory),
	};
	
注册jni函数的动作很简单，只是在遍历array数组，并尝试回调每个数组项的mProc回调函数.注册JNI其实也很好理解，主要写过JNI程序的都知道定义的JNI函数是给某个上层JAVA类调用的嘛，注册的意思就是注册给哪个类了，哪个类才能调用这些JNI函数。

iii. 找className指定的class的main函数，并以options为参数，调用main函数

AppRuntime的start()最后会加载Java层次的ZygoteInit类（com.android.internal.os.ZygoteInit），并利用JNI技术的CallStaticVoidMethod()调用其静态的main()函数，从这一步开始，Android系统从native层进入到了JAVA的世界了。

之后调用com.android.internel.os.ZygoteInit中的函数main启动了Zygote进程。此成员函数在framework/base/core/java/com/android/internel/os/ZygoteInit.java中：

	    public static void main(String argv[]) {
			try {
			    // Start profiling the zygote initialization.
			    SamplingProfilerIntegration.start();

			    boolean startSystemServer = false;
			    String socketName = "zygote";
			    String abiList = null;
			    for (int i = 1; i < argv.length; i++) {
				if ("start-system-server".equals(argv[i])) {
				    startSystemServer = true;
				} else if (argv[i].startsWith(ABI_LIST_ARG)) {
				    abiList = argv[i].substring(ABI_LIST_ARG.length());
				} else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
				    socketName = argv[i].substring(SOCKET_NAME_ARG.length());
				} else {
				    throw new RuntimeException("Unknown command line argument: " + argv[i]);
				}
			    }

			    if (abiList == null) {
				throw new RuntimeException("No ABI list supplied.");
			    }

			    //调用registerZygoteSocket创建一个Socket接口
			    registerZygoteSocket(socketName);
			    EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,
				SystemClock.uptimeMillis());
			    preload();
			    EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,
				SystemClock.uptimeMillis());

			    // Finish profiling the zygote initialization.
			    SamplingProfilerIntegration.writeZygoteSnapshot();

			    // Do an initial gc to clean up after startup
			    gc();

			    // Disable tracing so that forked processes do not inherit stale tracing tags from
			    // Zygote.
			    Trace.setTracingEnabled(false);

			    if (startSystemServer) {
				startSystemServer(abiList, socketName);
			    }

			    Log.i(TAG, "Accepting command socket connections");
			    //调用runSelectLoop进入无限循环，在前面创建的socket接口中等待ActivityManagerService请求，以创建新的应用程序进程
			    runSelectLoop(abiList);

			    closeServerSocket();
			} catch (MethodAndArgsCaller caller) {
			    caller.run();
			} catch (RuntimeException ex) {
			    Log.e(TAG, "Zygote died with exception", ex);
			    closeServerSocket();
			    throw ex;
			}
	    }
	    
它主要做了三件事情：
	1. 调用了registerZygoteSocket函数创建了一个Socket接口，用来和ActivityManagerService通讯；
	2. 调用了startSystemServer函数来启动Systemserver；
	3. 调用了runSelectLoop函数进入一个无限循环在前面创建的socket接口等待ActivityManagerService请求创建新的应用程序进程。
	
这里要留意 catch (MethodAndArgsCaller caller)这一行，android在这里通过抛出一个异常来处理正常的业务逻辑。

如何创建Socket上文已经分析过，下面讲一讲systemServer的启动。

## 启动systemServer

    /** 
     * Prepare the arguments and fork for the system server process.
     */
    private static boolean startSystemServer(String abiList, String socketName)
            throws MethodAndArgsCaller, RuntimeException {
        long capabilities = posixCapabilitiesAsBits(
            OsConstants.CAP_BLOCK_SUSPEND,
            OsConstants.CAP_KILL,
            OsConstants.CAP_NET_ADMIN,
            OsConstants.CAP_NET_BIND_SERVICE,
            OsConstants.CAP_NET_BROADCAST,
            OsConstants.CAP_NET_RAW,
            OsConstants.CAP_SYS_MODULE,
            OsConstants.CAP_SYS_NICE,
            OsConstants.CAP_SYS_RESOURCE,
            OsConstants.CAP_SYS_TIME,
            OsConstants.CAP_SYS_TTY_CONFIG
        );
        /* Hardcoded command line to start the system server */
        String args[] = { 
            "--setuid=1000",
            "--setgid=1000",
            "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007",
            "--capabilities=" + capabilities + "," + capabilities,
            "--runtime-init",
            "--nice-name=system_server",
            "com.android.server.SystemServer",
        };
        ZygoteConnection.Arguments parsedArgs = null;

        int pid;

        try {
            parsedArgs = new ZygoteConnection.Arguments(args);
            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);

            /* Request to fork the system server process */
            pid = Zygote.forkSystemServer(
                    parsedArgs.uid, parsedArgs.gid,
                    parsedArgs.gids,
                    parsedArgs.debugFlags,
                    null,
                    parsedArgs.permittedCapabilities,
                    parsedArgs.effectiveCapabilities);
        } catch (IllegalArgumentException ex) {
            throw new RuntimeException(ex);
        }

        /* For child process */
        if (pid == 0) {
            if (hasSecondZygote(abiList)) {
                waitForSecondaryZygote(socketName);
            }

            handleSystemServerProcess(parsedArgs);
        }

        return true;
    } 

这里我们可以从参数推测出：创建名为“system_server”的进程，其入口是： com.android.server.SystemServer 的 main 函数。zygote 进程通过 Zygote.forkSystemServer 函数来创建一个新的进程来启动 SystemServer 组件，返回值 pid 等 0 的地方就是新的进程要执行的路径，即新创建的进程会执行 handleSystemServerProcess 函数。hasSecondZygote 是针对 init.zygote64_32.rc， init.zygote32_64.rc 这两者情况的，在这里跳过不谈。接下来来看 handleSystemServerProcess：

    /**
     * Finish remaining work for the newly forked system server process.
     */
    private static void handleSystemServerProcess(
            ZygoteConnection.Arguments parsedArgs)
            throws ZygoteInit.MethodAndArgsCaller {

        closeServerSocket();

        // set umask to 0077 so new files and directories will default to owner-only permissions.
        Os.umask(S_IRWXG | S_IRWXO);

        if (parsedArgs.niceName != null) {
            Process.setArgV0(parsedArgs.niceName);
        }

        final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
        if (systemServerClasspath != null) {
            performSystemServerDexOpt(systemServerClasspath);
        }

        if (parsedArgs.invokeWith != null) {
            String[] args = parsedArgs.remainingArgs;
            // If we have a non-null system server class path, we'll have to duplicate the
            // existing arguments and append the classpath to it. ART will handle the classpath
            // correctly when we exec a new process.
            if (systemServerClasspath != null) {
                String[] amendedArgs = new String[args.length + 2];
                amendedArgs[0] = "-cp";
                amendedArgs[1] = systemServerClasspath;
                System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);
            }

            WrapperInit.execApplication(parsedArgs.invokeWith,
                    parsedArgs.niceName, parsedArgs.targetSdkVersion,
                    null, args);
        } else {
            ClassLoader cl = null;
            if (systemServerClasspath != null) {
                cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());
                Thread.currentThread().setContextClassLoader(cl);
            }

            /*
             * Pass the remaining arguments to SystemServer.
             */
            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
        }

        /* should never reach here */
    }
    
handleSystemServerProcess 会抛出 MethodAndArgsCaller 异常，前面提到这个异常其实是处理正常业务逻辑的，相当于一个回调。由于由 zygote 进程创建的子进程会继承 zygote 进程在前面创建的 socket 文件描述符，而这里的子进程又不会用到它，因此，这里就调用 closeServerSocket 函数来关闭它。SYSTEMSERVERCLASSPATH 是包含 /system/framework/framework.jar 的环境变量，它定义在 system/core/rootdir/init.environ.rc.in 中：

    on init
        export PATH /sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin
        export ANDROID_BOOTLOGO 1
        export ANDROID_ROOT /system
        export SYSTEMSERVERCLASSPATH %SYSTEMSERVERCLASSPATH%
        export LD_PRELOAD libsigchain.so

handleSystemServerProcess 函数接着调用 RuntimeInit.zygoteInit 函数来进一步执行启动 SystemServer 组件的操作。

    public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
            throws ZygoteInit.MethodAndArgsCaller {

        commonInit();
        nativeZygoteInit();

        applicationInit(targetSdkVersion, argv, classLoader);
    }

AndroidRuntime 是个带虚函数的基类，真正的实现是在 app_main.cpp 中的 AppRuntime:

	class AppRuntime : public AndroidRuntime
	{
	public:
	    AppRuntime(char* argBlockStart, const size_t argBlockLength)
		: AndroidRuntime(argBlockStart, argBlockLength)
		, mClass(NULL)
	    {   
	    }   

	    void setClassNameAndArgs(const String8& className, int argc, char * const *argv) {
		mClassName = className;
		for (int i = 0; i < argc; ++i) {
		     mArgs.add(String8(argv[i]));
		}
	    }   

	    virtual void onVmCreated(JNIEnv* env)
	    {   
		if (mClassName.isEmpty()) {
		    return; // Zygote. Nothing to do here.
		}

		/*
		 * This is a little awkward because the JNI FindClass call uses the
		 * class loader associated with the native method we're executing in.
		 * If called in onStarted (from RuntimeInit.finishInit because we're
		 * launching "am", for example), FindClass would see that we're calling
		 * from a boot class' native method, and so wouldn't look for the class
		 * we're trying to look up in CLASSPATH. Unfortunately it needs to,
		 * because the "am" classes are not boot classes.
		 *
		 * The easiest fix is to call FindClass here, early on before we start
		 * executing boot class Java code and thereby deny ourselves access to
		 * non-boot classes.
		 */
		char* slashClassName = toSlashClassName(mClassName.string());
		mClass = env->FindClass(slashClassName);
		if (mClass == NULL) {
		    ALOGE("ERROR: could not find class '%s'\n", mClassName.string());
		}
		free(slashClassName);

		mClass = reinterpret_cast<jclass>(env->NewGlobalRef(mClass));
	    }

	    virtual void onStarted()
	    {
		sp<ProcessState> proc = ProcessState::self();
		ALOGV("App process: starting thread pool.\n");
		proc->startThreadPool();

		AndroidRuntime* ar = AndroidRuntime::getRuntime();
		ar->callMain(mClassName, mClass, mArgs);

		IPCThreadState::self()->stopProcess();
	    }

	    virtual void onZygoteInit()
	    {
		// Re-enable tracing now that we're no longer in Zygote.
		atrace_set_tracing_enabled(true);

		sp<ProcessState> proc = ProcessState::self();
		ALOGV("App process: starting thread pool.\n");
		proc->startThreadPool();
	    }

	    virtual void onExit(int code)
	    {
		if (mClassName.isEmpty()) {
		    // if zygote
		    IPCThreadState::self()->stopProcess();
		}

		AndroidRuntime::onExit(code);
	    }


	    String8 mClassName;
	    Vector<String8> mArgs;
	    jclass mClass;
	};
通过执行 AppRuntime::onZygoteInit 函数，这个进程的 Binder 进程间通信机制基础设施就准备好了，参考代码 frameworks/native/libs/binder/ProcessState.cpp。

    private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
            throws ZygoteInit.MethodAndArgsCaller {

        final Arguments args;
        try {
            args = new Arguments(argv);
        } catch (IllegalArgumentException ex) {
            Slog.e(TAG, ex.getMessage());
            // let the process exit
            return;
        }

        // Remaining arguments are passed to the start class's static main
        invokeStaticMain(args.startClass, args.startArgs, classLoader);
    }

applicationInit 仅仅是转调 invokeStaticMain：

    private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)
            throws ZygoteInit.MethodAndArgsCaller
    {
        Class cl;
        cl = Class.forName(className, true, classLoader);
        Method m;
        m = cl.getMethod("main", new Class[] { String[].class });


        /*
         * This throw gets caught in ZygoteInit.main(), which responds
         * by invoking the exception's run() method. This arrangement
         * clears up all the stack frames that were required in setting
         * up the process.
         */
        throw new ZygoteInit.MethodAndArgsCaller(m, argv);
    }

invokeStaticMain 也很简单，通过反射找到参数 className 对应的类的静态 main 方法，然后将该方法与参数生成 ZygoteInit.MethodAndArgsCaller 对象当做异常抛出，这个异常对象在 ZygoteInit 的 main 函数被捕获并执行该对象的 run 方法。

    /**
     * Helper exception class which holds a method and arguments and
     * can call them. This is used as part of a trampoline to get rid of
     * the initial process setup stack frames.
     */
    public static class MethodAndArgsCaller extends Exception
            implements Runnable {

        public void run() {
            ...
            mMethod.invoke(null, new Object[] { mArgs });
            ...
        }
    }

这么复杂的跳转，其实就做了一件简单的事情：根据 className 反射调用该类的静态 main 方法。这个类名是 ZygoteInit.startSystemServer 方法中写死的 com.android.server.SystemServer。 从而进入 SystemServer 类的 main()方法。

## 执行ZygoteInit.runSelectLoop

在 startSystemServer 函数中，创建 system_server 进程之后，pid 等于 0 时在该新进程中执行 SystemServer.main，否则回到 zygote 进程进行执行 ZygoteInit.runSelectLoop：

    private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {
        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();
        FileDescriptor[] fdArray = new FileDescriptor[4];

        fds.add(sServerSocket.getFileDescriptor());
        peers.add(null);

        int loopCount = GC_LOOP_COUNT;
        while (true) {
            int index;

            /*
             * Call gc() before we block in select().
             * It's work that has to be done anyway, and it's better
             * to avoid making every child do it.  It will also
             * madvise() any free memory as a side-effect.
             *
             * Don't call it every time, because walking the entire
             * heap is a lot of overhead to free a few hundred bytes.
             */
            if (loopCount <= 0) {
                gc();
                loopCount = GC_LOOP_COUNT;
            } else {
                loopCount--;
            }

            try {
                fdArray = fds.toArray(fdArray);
                index = selectReadable(fdArray);
            } catch (IOException ex) {
                throw new RuntimeException("Error in select()", ex);
            }

            if (index < 0) {
                throw new RuntimeException("Error in select()");
            } else if (index == 0) {
                ZygoteConnection newPeer = acceptCommandPeer(abiList);
                peers.add(newPeer);
                fds.add(newPeer.getFileDescriptor());
            } else {
                boolean done;
                done = peers.get(index).runOnce();

                if (done) {
                    peers.remove(index);
                    fds.remove(index);
                }
            }
        }
    }

runSelectLoop函数的逻辑比较简单，主要有两点： 
1. 处理客户端的连接和请求。前面创建的 LocalServerSocket 对象保存 sServerSocket，这个 socket 通过 selectReadable 等待 ActivityManagerService(简写 AMS) 与之通信。selectReadable 是一个native函数，内部调用select等待 AMS 连接，AMS 连接上之后就会返回: 返回值 < 0：内部发生错误；返回值 = 0：第一次连接到服务端 ；返回值 > 0：与服务端已经建立连接，并开始发送数据。每一个链接在 zygote 进程中使用 ZygoteConnection 对象表示。
2. 客户端的请求由 ZygoteConnection.runOnce 来处理，这个方法也抛出 MethodAndArgsCaller 异常，从而进入 MethodAndArgsCaller.run 中调用根据客户请求数据反射出的类的 main 方法.

    private String[] readArgumentList()
    {
        int argc;

        try {
            String s = mSocketReader.readLine();

            if (s == null) {
                // EOF reached.
                return null;
            }
            argc = Integer.parseInt(s);
        } catch (NumberFormatException ex) {
            Log.e(TAG, "invalid Zygote wire format: non-int at argc");
            throw new IOException("invalid wire format");
        }

        String[] result = new String[argc];
        for (int i = 0; i < argc; i++) {
            result[i] = mSocketReader.readLine();
            if (result[i] == null) {
                // We got an unexpected EOF.
                throw new IOException("truncated request");
            }
        }

        return result;
    }

    boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
        String args[];
        Arguments parsedArgs = null;
        args = readArgumentList();
        parsedArgs = new Arguments(args);

        ...
        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,
                parsedArgs.appDataDir);
        ...
    }

## systemServer 启动过程

在前面启动 SystemServer一节讲到，通过反射调用类 com.android.server.SystemServer main() 函数，从而开始执行 SystemServer 的初始化流程。

SystemServer.main()

    /**
     * The main entry point from zygote.
     */
    public static void main(String[] args) {
        new SystemServer().run();
    }

main 函数创建一个 SystemServer 对象，调用其 run() 方法。

    private void run() {
        // If a device's clock is before 1970 (before 0), a lot of
        // APIs crash dealing with negative numbers, notably
        // java.io.File#setLastModified, so instead we fake it and
        // hope that time from cell towers or NTP fixes it shortly.
        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {
            Slog.w(TAG, "System clock is before 1970; setting to 1970.");
            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
        } // 检测时间设置

        // Here we go!
        Slog.i(TAG, "Entered the Android system server!");
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());

        // In case the runtime switched since last boot (such as when
        // the old runtime was removed in an OTA), set the system
        // property so that it is in sync. We can't do this in
        // libnativehelper's JniInvocation::Init code where we already
        // had to fallback to a different runtime because it is
        // running as root and we need to be the system user to set
        // the property. http://b/11463182
        SystemProperties.set("persist.sys.dalvik.vm.lib.2", VMRuntime.getRuntime().vmLibrary());

        // Enable the sampling profiler.
        if (SamplingProfilerIntegration.isEnabled()) {
            SamplingProfilerIntegration.start();
            mProfilerSnapshotTimer = new Timer();
            mProfilerSnapshotTimer.schedule(new TimerTask() {
                @Override
                public void run() {
                    SamplingProfilerIntegration.writeSnapshot("system_server", null);
                }
            }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);
        } // 启动性能分析采样

        // Mmmmmm... more memory!
        VMRuntime.getRuntime().clearGrowthLimit();

        // The system server has to run all of the time, so it needs to be
        // as efficient as possible with its memory usage.
        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);

        // Some devices rely on runtime fingerprint generation, so make sure
        // we've defined it before booting further.
        Build.ensureFingerprintProperty();

        // Within the system server, it is an error to access Environment paths without
        // explicitly specifying a user.
        Environment.setUserRequired(true);

        // Ensure binder calls into the system always run at foreground priority.
        BinderInternal.disableBackgroundScheduling(true);

        // Prepare the main looper thread (this thread).
        android.os.Process.setThreadPriority(
                android.os.Process.THREAD_PRIORITY_FOREGROUND);
        android.os.Process.setCanSelfBackground(false);
        Looper.prepareMainLooper(); // 准备主线程循环

        // Initialize native services.
        System.loadLibrary("android_servers");
        nativeInit();

        // Check whether we failed to shut down last time we tried.
        // This call may not return.
        performPendingShutdown();

        // Initialize the system context.
        createSystemContext();

        // Create the system service manager.
        mSystemServiceManager = new SystemServiceManager(mSystemContext);
        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);

        // Start services.  // 启动服务
        try {
            startBootstrapServices();
            startCoreServices();
            startOtherServices();
        } catch (Throwable ex) {
            Slog.e("System", "******************************************");
            Slog.e("System", "************ Failure starting system services", ex);
            throw ex;
        }

        // For debug builds, log event loop stalls to dropbox for analysis.
        if (StrictMode.conditionallyEnableDebugLogging()) {
            Slog.i(TAG, "Enabled StrictMode for system server main thread.");
        }

        // Loop forever.
        Looper.loop();  // 启动线程循环，等待消息处理
        throw new RuntimeException("Main thread loop unexpectedly exited");
    }

在这个 run 方法中，主要完成三件事情，创建 system context 和 system service manager，启动一些系统服务，进入主线程消息循环。

## Zygote的fork本地方法分析

接下来我们仔细分析 Zygote.forkSystemServer 与 Zygote.forkAndSpecialize 两个方法。

    private static final ZygoteHooks VM_HOOKS = new ZygoteHooks();

    public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,
	    int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
	VM_HOOKS.preFork();
	int pid = nativeForkSystemServer(
	        uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);
	VM_HOOKS.postForkCommon();
	return pid;
    }

在调用 nativeForkSystemServer 创建 system_server 进程之前与之后，都会调用 ZygoteHooks 进行一些前置与后置处理。

	   public void preFork() {
		Daemons.stop();
		waitUntilAllThreadsStopped();
		token = nativePreFork();
	    }
    
Daemons.stop(); 停止虚拟机中一些守护线程操作：如引用队列、终接器、GC等。

    public static void stop() {
        ReferenceQueueDaemon.INSTANCE.stop();
        FinalizerDaemon.INSTANCE.stop();
        FinalizerWatchdogDaemon.INSTANCE.stop();
        HeapTrimmerDaemon.INSTANCE.stop();
        GCDaemon.INSTANCE.stop();
    }

waitUntilAllThreadsStopped 保证被 fork 的进程是单线程，这样可以确保通过 copyonwrite fork 出来的进程也是单线程，从而节省资源。与前面提到的在新建 system_server 进程中调用 closeServerSocket 关闭 sockect 有异曲同工之妙。

    /**
     * We must not fork until we're single-threaded again. Wait until /proc shows we're
     * down to just one thread.
     */
    private static void waitUntilAllThreadsStopped() {
        File tasks = new File("/proc/self/task");
        while (tasks.list().length > 1) {
            try {
                // Experimentally, booting and playing about with a stingray, I never saw us
                // go round this loop more than once with a 10ms sleep.
                Thread.sleep(10);
            } catch (InterruptedException ignored) {
            }
        }
    }

本地方法 nativePreFork 实现在 art/runtime/native/dalvik_system_ZygoteHooks.cc 中。

    static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {
      Runtime* runtime = Runtime::Current();
      CHECK(runtime->IsZygote()) << "runtime instance not started with -Xzygote";

      runtime->PreZygoteFork();

      // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.
      Thread* self = Thread::Current();
      return reinterpret_cast<jlong>(self);
    }

ZygoteHooks_nativePreFork 通过调用 Runtime::PreZygoteFork 来完成 gc 堆的一些初始化，这部分代码在 art/runtime/runtime.cc 中：

    heap_ = new gc::Heap(...);
    void Runtime::PreZygoteFork() {
        heap_->PreZygoteFork();
    }
    
## 创建SystemServer进程
 
 nativeForkSystemServer 实现在 framework/base/core/jni/com_android_internal_os_Zygote.cpp 中：
 
     static jint com_android_internal_os_Zygote_nativeForkSystemServer(
            JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,
            jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,
            jlong effectiveCapabilities) {
        pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids,
                        debug_flags, rlimits,
                        permittedCapabilities, effectiveCapabilities,
                        MOUNT_EXTERNAL_NONE, NULL, NULL, true, NULL,
                        NULL, NULL);
        if (pid > 0) {
            // The zygote process checks whether the child process has died or not.
            ALOGI("System server process %d has been created", pid);
            gSystemServerPid = pid;
            // There is a slight window that the system server process has crashed
            // but it went unnoticed because we haven't published its pid yet. So
            // we recheck here just to make sure that all is well.
            int status;
            if (waitpid(pid, &status, WNOHANG) == pid) {
                ALOGE("System server process %d has died. Restarting Zygote!", pid);
                RuntimeAbort(env);
            }
        }
        return pid;
    }

它转调 ForkAndSpecializeCommon 来创建新进程，并确保 system_server 创建成功，若不成功便成仁：重启 zygote，因为没有 system_server 就干不了什么事情。ForkAndSpecializeCommon 实现如下：

    static const char kZygoteClassName[] = "com/android/internal/os/Zygote";
    gZygoteClass = (jclass) env->NewGlobalRef(env->FindClass(kZygoteClassName));
    gCallPostForkChildHooks = env->GetStaticMethodID(gZygoteClass, "callPostForkChildHooks",
                                           "(ILjava/lang/String;)V");

    // Utility routine to fork zygote and specialize the child process.
    static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,
                     jint debug_flags, jobjectArray javaRlimits,
                     jlong permittedCapabilities, jlong effectiveCapabilities,
                     jint mount_external,
                     jstring java_se_info, jstring java_se_name,
                     bool is_system_server, jintArray fdsToClose,
                     jstring instructionSet, jstring dataDir)
    {
        SetSigChldHandler();

        pid_t pid = fork();

        if (pid == 0) {
            // The child process.
            ...
            rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);
            ...
            UnsetSigChldHandler();
            ...
            env->CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,
                          is_system_server ? NULL : instructionSet);
        }
        else if (pid > 0) {
            // the parent process
        }

        return pid;
    }

ForkAndSpecializeCommon 首先设置子进程异常处理handler，然后 fork 新进程，在新进程中设置 SELinux，并清除它的子进程异常处理 handler，然后调用 Zygote.callPostForkChildHooks 方法。

    private static void callPostForkChildHooks(int debugFlags, String instructionSet) {
        long startTime = SystemClock.elapsedRealtime();
        VM_HOOKS.postForkChild(debugFlags, instructionSet);
        checkTime(startTime, "Zygote.callPostForkChildHooks");
    }

callPostForkChildHooks 又转调 ZygoteHooks.postForkChild :

    public void postForkChild(int debugFlags, String instructionSet) {
        nativePostForkChild(token, debugFlags, instructionSet);
    }
    
本地方法 nativePostForkChild 又进到 dalvik_system_ZygoteHooks.cc 中：

    static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags,
                                            jstring instruction_set) {
        Thread* thread = reinterpret_cast<Thread*>(token);
        // Our system thread ID, etc, has changed so reset Thread state.
        thread->InitAfterFork();
        EnableDebugFeatures(debug_flags);

        if (instruction_set != nullptr) {
            ScopedUtfChars isa_string(env, instruction_set);
            InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());
            Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;
            if (isa != kNone && isa != kRuntimeISA) {
                action = Runtime::NativeBridgeAction::kInitialize;
            }
            Runtime::Current()->DidForkFromZygote(env, action, isa_string.c_str());
        } else {
            Runtime::Current()->DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, nullptr);
        }

thread->InitAfterFork(); 实现在 art/runtime/thread.cc 中，设置新进程主线程的线程id： tid。DidForkFromZygote 实现在 Runtime.cc 中：

    void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) {
        is_zygote_ = false;

        switch (action) {
        case NativeBridgeAction::kUnload:
            UnloadNativeBridge();
            break;

        case NativeBridgeAction::kInitialize:
            InitializeNativeBridge(env, isa);
            break;
        }

        // Create the thread pool.
        heap_->CreateThreadPool();

        StartSignalCatcher();

        // Start the JDWP thread. If the command-line debugger flags specified "suspend=y",
        // this will pause the runtime, so we probably want this to come last.
        Dbg::StartJdwp();
    }

首先根据 action 参数来卸载或转载用于跨平台桥接用的库。然后启动 gc 堆的线程池。StartSignalCatcher 设置信号 处理 handler，其代码在 signal_catcher.cc 中。

后置处理 ZygoteHooks.postForkCommon：

    public void postForkCommon() {
        Daemons.start();
    }
    
postForkCommon 转调 Daemons.start，以初始化虚拟机中引用队列、终接器以及 gc 的守护线程。

    public static void start() {
        ReferenceQueueDaemon.INSTANCE.start();
        FinalizerDaemon.INSTANCE.start();
        FinalizerWatchdogDaemon.INSTANCE.start();
        HeapTrimmerDaemon.INSTANCE.start();
        GCDaemon.INSTANCE.start();
    }

    public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,
          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,
          String instructionSet, String appDataDir) {
        long startTime = SystemClock.elapsedRealtime();
        VM_HOOKS.preFork();
        checkTime(startTime, "Zygote.preFork");
        int pid = nativeForkAndSpecialize(
                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,
                  instructionSet, appDataDir);
        checkTime(startTime, "Zygote.nativeForkAndSpecialize");
        VM_HOOKS.postForkCommon();
        checkTime(startTime, "Zygote.postForkCommon");
        return pid;
    }

前置处理与后置处理与 forkSystemServer 中一样的，这里就跳过不讲了。本地方法 nativeForkAndSpecialize 实现在 framework/base/core/jni/com_android_internal_os_Zygote.cpp 中：

static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(
        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,
        jint debug_flags, jobjectArray rlimits,
        jint mount_external, jstring se_info, jstring se_name,
        jintArray fdsToClose, jstring instructionSet, jstring appDataDir) {
    // Grant CAP_WAKE_ALARM to the Bluetooth process.
    jlong capabilities = 0;
    if (uid == AID_BLUETOOTH) {
        capabilities |= (1LL << CAP_WAKE_ALARM);
    }

    return ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,
            rlimits, capabilities, capabilities, mount_external, se_info,
            se_name, false, fdsToClose, instructionSet, appDataDir);
}

这个函数与 com_android_internal_os_Zygote_nativeForkSystemServer 非常类似，只不过少了一个确保子进程创建成功的步骤。
